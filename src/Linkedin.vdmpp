class Linkedin
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
	-- users of the social network
	private users: set of User := {};
	
	--groups of the social network
	private groups: map seq1 of char to Group := {|->};
	
operations
	-- constructor
	public Linkedin: () ==> Linkedin
	Linkedin() == return self
	post users = {};
	
	-- add a new user to the social network
	public addUser: User ==> ()
	addUser(user) == users := users union {user}
	pre user not in set users
	post users = users~ union {user};
	
	-- add a new connections between users
	public addConnection: User * User ==> ()
	addConnection(user1, user2) ==
	|| (user1.addConnection(user2), user2.addConnection(user1))
	pre
			-- they are not the same user
			user1 <> user2 and
			-- both users exist in the database
			user1 in set users and
			user2 in set users and
			-- there's no connection between them
			user2 not in set user1.connections and
			user1 not in set user2.connections
	post user2 in set user1.connections and user1 in set user2.connections;
	
	-- add a new group to the social network (each group name is unique)
	public addGroup: seq1 of char ==> ()
	addGroup(name) == groups := groups munion {name |-> new Group()}
	pre name in set dom groups;
	
	-- send a message to a group
	public msgGroup: seq1 of char * User * seq1 of char ==> ()
	msgGroup(groupName, user, msg) == groups(groupName).sendMsg(user, msg)
	pre user in set users and groupName in set dom groups;
	
	-- returns the most popular group in the social network
	public mostPopularGroup: () ==> seq1 of char
	mostPopularGroup() == (
		dcl name: [seq1 of char] := nil;
		
		for all groupName in set dom groups do
			if name = nil or len groups(groupName).msgs > len groups(name).msgs then
				name := groupName;
		
		return name
	)
	post RESULT in set dom groups;
	
	-- returns the names of all groups in the social network
	public getGroupNames: () ==> set of seq1 of char
	getGroupNames() == return dom groups;
	
	-- returns all the information about a group
	public getGroupInfo: seq1 of char ==> Group
	getGroupInfo(name) == return groups(name)
	pre name in set dom groups;
	
	-- returns all users that have a similar name to the given one
	public searchByName: seq of char ==> set of User
	searchByName(name) == (
	dcl results: set of User := {};
	
	for all user in set users do (
		if user.similarName(name) then
			results := results union {user};
	);
	
	return results)
	pre len name > 0;
	
	-- returns commun contacts between two users
	public findConnections: User * User ==> set of User
	findConnections(user1, user2) ==
		return user1.connections inter user2.connections
	pre user1 <> user2 and user1 in set users and user2 in set users;
	
	-- returns the most famous person in the network
	public mostFamous: () ==> User
	mostFamous() ==
	(
		dcl famous: [User] := nil;
		
		for all user in set users do
			if famous = nil or card user.connections > card famous.connections then
				famous := user;
		
		return famous
	)
	pre card users > 0
	post RESULT in set users;
	
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Linkedin